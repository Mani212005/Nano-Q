<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nano Meta-Prompting Summarizer</title>
    
    <!-- MANDATORY FIX: Simplified Permissions Policy for model-execution -->
    <!-- This is the absolute minimum policy required to access the LanguageModel API. -->
    <meta http-equiv="Permissions-Policy" content="model-execution *">

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chart.js for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- Custom style for responsive canvas -->
    <style>
        /* Ensures the canvas container adapts to screen size */
        #chartContainer {
            width: 100%;
            height: 400px;
            max-width: 800px;
            margin: 2rem auto;
            position: relative;
        }
        .text-area-container {
            min-height: 250px;
        }
        /* Custom scrollbar style for better aesthetics */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-thumb {
            background-color: #6366f1; /* Indigo-500 */
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans p-4 min-h-screen flex flex-col items-center">

    <div class="w-full max-w-4xl bg-white shadow-xl rounded-xl p-8 space-y-8">
        <h1 class="text-3xl font-extrabold text-indigo-700 text-center">
            Nano Visual Summarizer <span class="text-lg font-light text-gray-500 block">(Two-Stage Meta-Prompting)</span>
        </h1>
        <p class="text-sm text-center text-gray-600">
            This application uses Chrome's built-in AI (Gemini Nano) for **client-side, privacy-preserving** summarization via a two-stage meta-prompting pipeline.
            <br><strong class="text-red-500">CRITICAL PREREQUISITE: Requires Chrome with Prompt API flags enabled, AND the file MUST be served over HTTP (e.g., using a local development server like localhost) to satisfy the 'Permissions-Policy' security check.</strong>
        </p>

        <!-- Input Area -->
        <div class="space-y-4">
            <label for="textInput" class="block text-lg font-semibold text-gray-700">Paste Document Text Here:</label>
            <textarea id="textInput" rows="10" class="w-full p-4 border border-indigo-300 rounded-lg text-gray-800 focus:ring-2 focus:ring-indigo-500 transition duration-150 text-area-container" placeholder="E.g., A long article, report, or summary of a novel.">The Artemis program represents NASA's ambitious plan to return humans to the Moon, establishing a sustainable presence that paves the way for missions to Mars. Phase 1, which included the uncrewed Artemis I mission, successfully tested the massive Space Launch System (SLS) rocket and the Orion crew capsule in late 2022, proving key technologies. The primary goal is Artemis III, scheduled for 2026, which aims to land the first woman and the next man on the Moon's South Pole, a region rich in water ice. However, the program faces significant budget constraints and scheduling delays, pushing the initial 2025 landing target back. Funding levels have been inconsistent, creating challenges for the development of the Human Landing System (HLS), which is contracted to SpaceX's Starship. Despite the technical hurdles, the long-term vision focuses heavily on international collaboration, with agencies like ESA and JAXA contributing critical components like the European Service Module (ESM). Success relies on sustained political and financial backing, as costs are projected to exceed $90 billion by 2028.</textarea>
        </div>

        <!-- Action Button -->
        <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 justify-center">
            <button id="summarizeButton" class="px-8 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 disabled:bg-indigo-300">
                Generate Visual Summary (2 Stages)
            </button>
        </div>

        <!-- Status and Debug Area -->
        <div id="statusArea" class="text-center p-3 border border-gray-200 rounded-lg text-sm text-gray-600 hidden">
            <p id="statusMessage" class="font-medium"></p>
            <div id="debugOutput" class="mt-2 text-xs text-left overflow-auto max-h-40 p-2 bg-gray-100 rounded-md"></div>
        </div>

        <!-- Chart Display Area -->
        <div id="chartContainer" class="hidden">
            <h2 id="chartTitle" class="text-xl font-bold text-center mb-4 text-indigo-700"></h2>
            <!-- Chart.js will render here -->
            <canvas id="summaryChart"></canvas>
        </div>
    </div>

    <script>
        // Check for the mandatory Chrome Built-in AI API
        const AI_API_AVAILABLE = ('LanguageModel' in window);
        if (!AI_API_AVAILABLE) {
            // Note: We use alert here only for the initial setup failure, which is outside the main app flow.
            // In a production app, we would use a custom UI dialog.
            alert("The Chrome Built-in AI API (LanguageModel) is not detected. Please ensure you are using a compatible Chrome version with the required flags enabled.");
            document.getElementById('summarizeButton').disabled = true;
            document.getElementById('summarizeButton').textContent = "API NOT AVAILABLE";
        }

        // --- SCHEMAS (Defined as the Blueprint for Gemini Nano) ---
        
        // Stage 1 Schema: Output for the Meta-Prompt (The instruction generator)
        const META_PROMPT_SCHEMA = {
            type: "object",
            properties: {
                chart_type_suggestion: {
                    type: "string",
                    description: "Based on the text, suggest the best chart type: 'bar' for comparisons, 'pie' for proportions, or 'line' for trends.",
                    enum: ["bar", "pie", "line"],
                },
                optimized_prompt: {
                    type: "string",
                    description: "A single, highly optimized instruction for the next stage of the model to extract data points for a chart summary. This prompt must not exceed 50 words and must include the chosen chart type.",
                },
            },
            required: ["chart_type_suggestion", "optimized_prompt"],
        };

        // Stage 2 Schema: Output for the final Chart Data (The data extractor)
        const CHART_DATA_SCHEMA = {
            type: "object",
            properties: {
                title: {
                    type: "string",
                    description: "A concise title summarizing the main topic of the text.",
                },
                data_points: {
                    type: "array",
                    description: "The top 3-5 most important topics or entities from the text.",
                    items: {
                        type: "object",
                        properties: {
                            label: {
                                type: "string",
                                description: "The key concept or entity name (e.g., 'Blockchain', 'Revenue', 'The Main Character').",
                            },
                            value: {
                                type: "integer",
                                description: "A score from 1 to 100 representing the importance or frequency of this concept in the text.",
                                minimum: 1,
                                maximum: 100,
                            },
                            summary: {
                                type: "string",
                                description: "A single, short sentence explaining this concept's role in the text.",
                            },
                        },
                        required: ["label", "value", "summary"],
                    },
                    minItems: 3,
                    maxItems: 5,
                },
            },
            required: ["title", "data_points"],
            propertyOrdering: ["title", "data_points"],
        };

        // Global Chart instance
        let chartInstance = null;
        let debugLog = [];

        // --- UTILITY FUNCTIONS ---

        /** Updates the status message and debug log visibility. */
        function updateStatus(message, isError = false) {
            const statusArea = document.getElementById('statusArea');
            const statusMessage = document.getElementById('statusMessage');
            
            statusArea.classList.remove('hidden');
            statusMessage.textContent = message;
            statusMessage.classList.toggle('text-red-500', isError);
            statusMessage.classList.toggle('text-gray-600', !isError);
        }

        /** Logs messages to the UI debug window. */
        function logDebug(message) {
            const debugOutput = document.getElementById('debugOutput');
            const timestamp = new Date().toLocaleTimeString();
            debugLog.push(`[${timestamp}] ${message}`);
            debugOutput.innerHTML = debugLog.join('<br>');
            // Scroll to bottom
            debugOutput.scrollTop = debugOutput.scrollHeight;
        }

        /**
         * The core wrapper for the Prompt API call with JSON constraint.
         * @param {string} promptText The prompt to send to Gemini Nano.
         * @param {object} schema The JSON schema constraint.
         * @returns {object|null} The parsed JSON object or null on error.
         */
        async function runNanoPrompt(promptText, schema) {
            let session = null;
            try {
                // Log availability status, which is key for debugging the external environment.
                const availability = await LanguageModel.availability();
                logDebug(`Model status check returned: '${availability}'. Attempting session creation...`);
                
                // Create a new session. This is the part that will trigger model download/loading if needed.
                session = await LanguageModel.create();
                logDebug("AI Session created successfully. Model is now active.");

                const result = await session.prompt(promptText, {
                    responseConstraint: schema,
                });
                
                // Log the raw result
                logDebug(`Got raw result: ${JSON.stringify(result, null, 2)}`);
                
                let parsed = null;
                
                if (typeof result === 'string') {
                    logDebug('Result is string, parsing...');
                    parsed = JSON.parse(result);
                } else if (result && result.text) {
                    logDebug('Result has .text property, parsing...');
                    parsed = JSON.parse(result.text);
                } else {
                    logDebug('Result is object, using as-is');
                    parsed = result;
                }
                
                logDebug(`Parsed result: ${JSON.stringify(parsed, null, 2)}`);

                // If result or result.text is missing, retry once after a short delay
                if (!result || !result.text) {
                    logDebug('Warning: Empty/invalid model response. Retrying once in 1s...');
                    await new Promise(r => setTimeout(r, 1000));
                    try {
                        result = await session.prompt(promptText, {
                            responseConstraint: schema,
                        });
                        logDebug('Retry attempt completed.');
                        try { console.debug('Retry model result object:', result); } catch (e) {}
                    } catch (retryError) {
                        logDebug(`Retry failed: ${retryError.message}`);
                    }
                }

                // Flexible response handling: the API may return a string, an object with `.text`,
                // an array of outputs, or already-parsed JSON. Try all reasonable extraction paths.
                function tryExtractJsonString(obj) {
                    if (!obj) return null;
                    // Direct string
                    if (typeof obj === 'string') return obj;
                    // Common field: text
                    if (typeof obj.text === 'string') return obj.text;
                    // Some implementations put outputs in an array
                    if (Array.isArray(obj.output) && obj.output.length > 0) {
                        const first = obj.output[0];
                        if (typeof first === 'string') return first;
                        if (typeof first.text === 'string') return first.text;
                    }
                    // Some variants include an 'outputs' field
                    if (Array.isArray(obj.outputs) && obj.outputs.length > 0) {
                        const first = obj.outputs[0];
                        if (typeof first === 'string') return first;
                        if (typeof first.text === 'string') return first.text;
                    }
                    // Fallback: no obvious string found
                    return null;
                }

                // If the result is already an object matching the schema, accept it directly.
                const looksLikeMeta = result && typeof result === 'object' && (result.chart_type_suggestion || result.optimized_prompt);
                const looksLikeChart = result && typeof result === 'object' && (result.title && result.data_points);
                if (looksLikeMeta || looksLikeChart) {
                    logDebug('Model returned an already-parsed object that matches the expected schema. Using it directly.');
                    return result;
                }

                // Try extracting a JSON string from common locations
                let rawText = tryExtractJsonString(result);

                // If nothing found, attempt to inspect object properties and stringify as a last resort
                if (!rawText && typeof result === 'object') {
                    try {
                        // stringify and see if it's JSON-like
                        const s = JSON.stringify(result);
                        if (s && s.length > 0) rawText = s;
                    } catch (e) {
                        // ignore
                    }
                }

                if (!rawText) {
                    logDebug('No textual payload found in model result object. Dumping object for inspection.');
                    try { console.debug('Unhandled model result shape:', result); } catch (e) {}
                    throw new Error('Invalid or empty response from the model');
                }

                // Clean common wrappers (code fences, markdown) before parsing
                function cleanWrappedJson(text) {
                    // Remove triple backticks and optional language hint
                    text = text.replace(/```[\s\S]*?```/g, (m) => m.replace(/(^```\w*|```$)/g, ''));
                    // Trim leading/trailing whitespace and possible single backticks
                    text = text.trim().replace(/^`|`$/g, '');
                    return text;
                }

                rawText = cleanWrappedJson(rawText);

                // Attempt to locate JSON object within the text (first '{' to last '}')
                function extractJsonSubstring(text) {
                    const first = text.indexOf('{');
                    const last = text.lastIndexOf('}');
                    if (first !== -1 && last !== -1 && last > first) {
                        return text.substring(first, last + 1);
                    }
                    return text;
                }

                const candidate = extractJsonSubstring(rawText);
                logDebug(`Raw response text received (Length: ${candidate.length}): ${candidate.substring(0, 200)}...`);

                try {
                    const parsed = JSON.parse(candidate);
                    return parsed;
                } catch (parseError) {
                    logDebug(`Failed to parse candidate JSON. Candidate: ${candidate}`);
                    throw new Error('Failed to parse model response as JSON');
                }

            } catch (error) {
                // IMPORTANT: Log the error, but use console.error for visibility during development
                console.error("Nano Prompt failed:", error); 
                
                let userMessage = "AI Processing Failed. Please check the following:";

                if (error.message.includes('Permissions Policy')) {
                    // FINAL DIAGNOSTIC: This message advises the user on the necessary external fix.
                    userMessage = "CRITICAL FAILURE: Permissions Policy Blocked. To fix this, you MUST serve the app over HTTP (e.g., localhost). Quick Fix (Python): Navigate to the file's directory in your terminal and run 'python3 -m http.server'. Then, open http://localhost:8000 in Chrome.";
                } else if (error.message.includes('The model is not available')) {
                    userMessage += " **Model Unavailable.** Check `chrome://on-device-internals` status.";
                } else {
                    userMessage += " Unspecified error. See console.";
                }

                logDebug(`ERROR: Gemini Nano failed. Details: ${error.message}`);
                updateStatus(userMessage, true);
                return null;
            } finally {
                try {
                    if (session && typeof session.terminate === 'function') {
                        session.terminate();
                        logDebug("AI Session terminated.");
                    }
                } catch (e) {
                    logDebug("Note: Session cleanup failed (ignorable): " + e.message);
                }
            }
        }

        // --- STAGE 1 & 2 PIPELINE ---

        async function executeTwoStageSummary(textInput) {
            updateStatus("Starting Stage 1: Meta-Prompt Generation...", false);
            logDebug("Starting Stage 1: Asking Nano to generate the optimized prompt.");

            // --- STAGE 1: GENERATE OPTIMIZED PROMPT ---
            const metaPrompt = `
                Analyze the following document's content, theme, and structure. 
                Generate an ideal, short prompt (max 50 words) and a chart type suggestion
                that will instruct the next stage of the LLM to extract the core data for a visual summary.
                Document content: ${textInput}
                ---
                Generate a JSON object strictly following the provided schema.
            `;
            
            const metaData = await runNanoPrompt(metaPrompt, META_PROMPT_SCHEMA);
            if (!metaData) return;

            try {
                logDebug(`Stage 1 parsed metaData: ${JSON.stringify(metaData)}`);
                console.debug('Stage 1 parsed metaData:', metaData);
            } catch (e) {}

            logDebug(`[Stage 1 Success] Suggested Chart: ${metaData.chart_type_suggestion}. Optimized Prompt: ${metaData.optimized_prompt}`);

            // --- STAGE 2: EXECUTE OPTIMIZED PROMPT FOR DATA EXTRACTION ---
            updateStatus("Starting Stage 2: Executing Optimized Prompt for Data Extraction...", false);
            logDebug("Starting Stage 2: Asking Nano to extract structured chart data.");


            const stage2Prompt = `
                ${metaData.optimized_prompt} The analysis should be based ONLY on this text: ${textInput}
                Generate a JSON object strictly following the CHART_DATA_SCHEMA.
            `;

            // Extra debug information before Stage 2 call
            logDebug(`Stage 2 prompt length: ${stage2Prompt.length}. Preview: ${stage2Prompt.substring(0, 300).replace(/\n/g, ' ')}...`);
            console.debug('Stage 2 prompt:', stage2Prompt);

            let chartData = null;
            try {
                chartData = await runNanoPrompt(stage2Prompt, CHART_DATA_SCHEMA);
            } catch (stage2err) {
                logDebug(`Stage 2 call threw an exception: ${stage2err.message}`);
                console.error('Stage 2 exception:', stage2err);
                updateStatus('Stage 2 failed during model call. See debug output.', true);
                // Re-enable button so user can retry
                document.getElementById('summarizeButton').disabled = false;
                document.getElementById('summarizeButton').textContent = "Generate Visual Summary (2 Stages)";
                return;
            }
            if (!chartData) return;

            logDebug("[Stage 2 Success] Received structured data.");

            // Final step: Override the visualization type with Nano's Stage 1 suggestion
            chartData.visualization_type = metaData.chart_type_suggestion; 

            updateStatus("Summary generation complete. Rendering Chart...", false);
            renderChart(chartData);
        }

        // --- STAGE 3: VISUALIZATION ---

        function renderChart(structuredData) {
            const chartContainer = document.getElementById('chartContainer');
            chartContainer.classList.remove('hidden');

            document.getElementById('chartTitle').textContent = structuredData.title;

            const labels = structuredData.data_points.map(p => p.label);
            const dataValues = structuredData.data_points.map(p => p.value);
            const chartType = structuredData.visualization_type; 
            
            // Define colors for the chart
            const backgroundColors = [
                'rgba(255, 99, 132, 0.7)',  // Red
                'rgba(54, 162, 235, 0.7)',  // Blue
                'rgba(255, 206, 86, 0.7)',  // Yellow
                'rgba(75, 192, 192, 0.7)',  // Green
                'rgba(153, 102, 255, 0.7)'  // Purple
            ];

            // Destroy previous chart instance if it exists
            if (chartInstance) {
                chartInstance.destroy();
            }

            const ctx = document.getElementById('summaryChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: chartType === 'pie' ? 'doughnut' : 'bar', // Use doughnut for pie-like visualization
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Importance Score (1-100)',
                        data: dataValues,
                        backgroundColor: backgroundColors.slice(0, dataValues.length),
                        borderColor: '#4f46e5', // Indigo-600
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: structuredData.title,
                            font: { size: 18, weight: 'bold' }
                        },
                        legend: {
                            position: chartType === 'pie' ? 'right' : 'top',
                            labels: {
                                font: { size: 12 }
                            }
                        },
                        // KEY FEATURE: Tooltips show the one-sentence summary from Nano
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { weight: 'bold' },
                            bodyFont: { size: 14 },
                            callbacks: {
                                footer: (tooltipItems) => {
                                    const itemIndex = tooltipItems[0].dataIndex;
                                    // Find the corresponding data point object
                                    return structuredData.data_points[itemIndex].summary; 
                                }
                            }
                        }
                    },
                    // Specific axis configuration for bar/line charts
                    scales: chartType !== 'pie' ? {
                        y: {
                            beginAtZero: true,
                            max: 100, // Max score is 100
                            title: {
                                display: true,
                                text: 'Importance / Weight (%)'
                            }
                        }
                    } : {}
                }
            });
            updateStatus("Visual Summary Complete!", false);
            document.getElementById('summarizeButton').disabled = false;
            document.getElementById('summarizeButton').textContent = "Generate Visual Summary (2 Stages)";
        }

        // --- EVENT LISTENER ---

        document.getElementById('summarizeButton').addEventListener('click', async () => {
            if (!AI_API_AVAILABLE) {
                updateStatus("API is not available. Check Chrome flags.", true);
                return;
            }

            const textInput = document.getElementById('textInput').value.trim();
            if (textInput.length < 50) {
                updateStatus("Please enter a longer piece of text (min 50 chars) for analysis.", true);
                return;
            }

            // Reset UI and state
            document.getElementById('summarizeButton').disabled = true;
            document.getElementById('summarizeButton').textContent = "Processing... (Stage 1 of 2)";
            document.getElementById('chartContainer').classList.add('hidden');
            debugLog = [];
            
            await executeTwoStageSummary(textInput);
        });

    </script>
</body>
</html>
